<!DOCTYPE html>\
<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

    var config = {
        type: Phaser.AUTO,
        width: 1920,
        height: 1080,
        physics: {
            default: 'arcade',
            arcade: {
                debug: true,
                gravity: { y: 0 }
            }
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    var game = new Phaser.Game(config);

    //Game Objects
    var platforms;
    var squids;
    var map;
    var player;
    var seacreatures = [];
    var items = [];
    //Keyboard controls
    var cursors;
    var keys;
    var space;
    var p1ismovingx;
    var p1ismovingy;
    var p1ismoving;
    var p2ismovingx;
    var p2ismovingy;
    var p2ismoving;
    var isfaster;
    var graphics;
    var mad;
    var myTimeout;
    var squidmad;
    var squidcalm;

    function preload()
    {
        this.load.image('bg', 'backround.png');
        this.load.image('platform', 'platform.png');
        this.load.image('clarinet', 'clarinet.png');
        this.load.image('sunglasses', 'sunglasses.png');
        this.load.image('squidmad', 'SquidwardOpen.png');
        this.load.image('squidcalm', 'SquidwardClosed.png');
        this.load.atlas('seacreatures', 'spritesheet (1).png', 'spritesheet (2).json');
    }

    function create()
    {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
       let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'bg').setOrigin(0, 0);
        cursors = this.input.keyboard.createCursorKeys();

        var anims = this.anims.create({key: 'squidman', frames: this.anims.generateFrameNames('seacreatures', {prefix: 'player', end: 1, zeroPad: 1}), repeat: -1, frameRate: 10});

       //Create the platforms and the player character set to collide with the platforms
       createPlatforms(this);

        squids = this.physics.add.staticGroup();
        squidmad = squids.create(game.scale.width-210, 360, 'squidmad');
        squidcalm = squids.create(game.scale.width-210, 360, 'squidcalm');

       player = new Player(this, 400, 400, 'squid', anims);
       player2 = new Player(this, 400, 800, 'squid', anims);

       this.physics.add.collider(player, platforms);
       player.play(anims);
       player.body.setSize(500, 500);
       this.physics.add.overlap(player, items, collectItem, null, this);

        this.physics.add.collider(player2, platforms);
        player2.play(anims);
        player2.body.setSize(500, 500);
        this.physics.add.overlap(player2, items, collectItem, null, this);

       //Set up user input
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D, S, W');
        let myItem = new Item(this,  1920/2, 1080/2 );
        items.push(myItem);

        squidward = new Squidward(this);

       graphics = this.add.graphics();

        this.initialTime = 10000;

        text = this.add.text(32, 32, 'Countdown: ' + formatTime(this.initialTime / 1000));

        // Each 1000 ms call onEvent
        timedEvent = this.time.addEvent({ delay: 1, callback: onEvent, callbackScope: this, loop: true });
    }


    function formatTime(seconds){
        // Minutes
        var minutes = Math.floor(seconds/60);
        // Seconds
        var partInSeconds = seconds%60;
        // Adds left zeros to seconds
        partInSeconds = partInSeconds.toString().padStart(2,'0');
        // Returns formated time
        return `${minutes}:${partInSeconds}`;
    }


    function onEvent ()
    {
        this.initialTime -= 1; // One second
        text.setText('Countdown: ' + formatTime(this.initialTime));
    }

    function createPlatforms(scene)
    {
        platforms = scene.physics.add.staticGroup();

        //basePlatform is the floor of the game
        let basePlatform = platforms.create(game.scale.width/2, game.scale.height-30, 'platform');
        basePlatform.setScale(3, 1).refreshBody();

        platforms.create(250, 250, 'platform');
        platforms.create(950, 400, 'platform');
    }

    function update()
    {
        p1ismoving = p1ismovingy || p1ismovingx;
        p2ismoving = p2ismovingy || p2ismovingx;
        //Player will not move in the x-axis unless a movement key is being pressed
        //player.setVelocityX(0);

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(1500);
        player.setDragY(1500);
        playerOne();

        player2.setDragX(1500);
        player2.setDragY(1500);
        playerTwo();
        console.log(mad);

        if(mad && p1ismoving) {
            console.log("p1 died");
        }
        if(mad && p2ismoving) {
            console.log("p2 died");
        }

        var secTime = this.initialTime;
        var randNum = Phaser.Math.Between(0, 2000);
        if (secTime % 10 == 0)
        {
            if (randNum < 500){
                //console.log("off");
                let myItem = new Item(this,  Phaser.Math.Between(0, 2000), Phaser.Math.Between(0, 1500), 'clarinet');
                this.physics.add.collider(myItem, platforms);
                items.push(myItem);
            }
            else if (randNum < 1000){
                let myItem = new Item(this,  Phaser.Math.Between(0, 2000), Phaser.Math.Between(0, 1500), 'sunglasses');
                this.physics.add.collider(myItem, platforms);
                items.push(myItem);
            }
        }
        if (secTime % 500 == 0) {
            //console.log(mad);
            squidward.madge();
        }

        //console.log(player.isSunglasses);
    }

    function playerOne(){
        if (keys.A.isDown)
        {
            player.setVelocityX(-player.speed);
            // console.log(player.speed);
            p1ismovingx = true;
        }
        else if (keys.D.isDown)
        {
            player.setVelocityX(player.speed);
            p1ismovingx = true;
        }
        else
        {
            player.setVelocityX(0)
            p1ismovingx = false;
        }
        if (keys.S.isDown)
        {
            player.setVelocityY(player.speed);
            p1ismovingy = true;
        }
        else if (keys.W.isDown)
        {
            player.setVelocityY(-player.speed);
            p1ismovingy = true;
        }
        else
        {
            player.setVelocityY(0)
            p1ismovingy = false;
        }
    }
    function playerTwo(){
        if (cursors.left.isDown)
        {
            player2.setVelocityX(-player2.speed);
            // console.log(player.speed);
            p2ismovingx = true;
        }
        else if (cursors.right.isDown)
        {
            player2.setVelocityX(player2.speed);
            p2ismovingx = true;
        }
        else
        {
            player2.setVelocityX(0)
            p2ismovingx = false;
        }
        if (cursors.down.isDown)
        {
            player2.setVelocityY(player2.speed);
            p2ismovingy = true;
        }
        else if (cursors.up.isDown)
        {
            player2.setVelocityY(-player2.speed);
            p2ismovingy = true;
        }
        else
        {
            player2.setVelocityY(0)
            p2ismovingy = false;
        }

        //console.log(player.isSunglasses);
    }

    class Player extends Phaser.Physics.Arcade.Sprite
    {
        speed = 200;
        isSunglasses = false;
        constructor(scene, x, y, spritesheet)
        {
            super(scene, x, y, spritesheet);
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(0.1);
            this.setCollideWorldBounds(true);
            this.setGravityY(0);

        }

    }

    class Item extends Phaser.Physics.Arcade.Sprite
    {
        myItemType = 'clarinet';
        constructor(scene, x, y, itemType)
        {
            super(scene, x, y, itemType);
            this.myItemType = itemType;
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setCollideWorldBounds(true);
            this.setScale(0.1);
            //this.body.setSize(500, 500);
            // this.body.setOffset(-150, 150);
            this.setGravityY(0);
        }
    }



    class SeaCreature extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene, x, y, spritesheet,ani)
        {
            super(scene, x, y, spritesheet);
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(0.02);
            //this.play(ani);
        }

        addTween(scene, xDist, yDist, time)
        {
            scene.tweens.add({ targets: this, x: xDist, y: yDist, duration: time, ease: 'Sine.easeInOut', repeat: -1, yoyo: true });
        }
    }

    class Squidward {
        constructor(scene) {

            mad = false;
            squidmad.visible = false;
            squidcalm.visible = true;


        }
        madge() {
            mad = true;
            squidmad.visible = true;
            squidcalm.visible = false;
            setTimeout(sadge, 3000);

        }
        sadge() {
            mad = false;
        }
    }
    function collectItem(player, item)
    {
        item.disableBody(true, true); //remove that particular carrot from the game (physics and visibility)
        for (i = 0; i < items.length; i++){
            if (items[i] == item){
                if (items[i].myItemType == 'clarinet'){
                    player.speed = 100;
                    setTimeout(defaultPlayer, 3000);
                }
                else if (items[i].myItemType == 'sunglasses'){
                    player.isSunglasses = true;
                    setTimeout(defaultPlayer, 3000);
                }
            }
        }

    }
    function defaultPlayer() {
        // console.log("it works");
        player.speed = 200;
        player.isSunglasses = false;

    }
    function sadge() {
        mad = false;
        squidmad.visible = false;
        squidcalm.visible = true;
    }

    </script>

</body>

</html>
